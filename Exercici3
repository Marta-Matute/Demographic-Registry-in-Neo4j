Apartat a). Estudi de les components connexes (cc) i de l’estructura de les component en funció de la seva mida.


- Taula agrupant els resultats segons la mida de la cc.
CALL gds.graph.project('Graph1', ['PERSON', 'HOUSE'], 'LIVES');
CALL gds.graph.project('Graph2',['HOUSE','PERSON'],['FAMILY','SAME_AS','LIVES']);

CALL gds.wcc.stream('Graph2')
YIELD componentId, nodeId
RETURN componentId, size(collect(nodeId)) AS mida, collect(nodeId) AS nodes
ORDER BY mida DESC;

- Distribució de tipus de nodes (Individu o Habitatge) segons la mida de la cc.
Distribució segons municipi del Habitatge:
CALL gds.wcc.stream('Graph2')
YIELD nodeId, componentId
WHERE gds.util.asNode(nodeId).Municipality is not null
RETURN distinct gds.util.asNode(nodeId).Municipality AS municipi, size(collect(distinct componentId)) AS mida
ORDER BY municipi

Per veure quin son els 10 noms amb mes realcions:
CALL gds.wcc.stream('Graph2')
YIELD nodeId, componentId
WHERE gds.util.asNode(nodeId).Name is not null
RETURN distinct gds.util.asNode(nodeId).Name AS nom, size(collect(distinct componentId)) AS mida
ORDER BY mida DESC
LIMIT 10

I els 10 cognoms amb mes relacions:
CALL gds.wcc.stream('fams')
YIELD nodeId, componentId
WHERE gds.util.asNode(nodeId).Last_Name <> 'nan'
RETURN distinct gds.util.asNode(nodeId).Last_Name AS nom, size(collect(distinct componentId)) AS mida
ORDER BY mida DESC
LIMIT 10;



- Per cada municipi i any el nombre de parelles del tipus: (Individu)—(Habitatge)

CALL gds.graph.project('Graph','PERSON','LIVES');

CALL gds.wcc.stream('Graph')
YIELD componentId, nodeId
WITH componentId, collect(nodeId) AS nodes, size(collect(nodeId)) AS mida
ORDER BY mida DESC
MATCH path=((n)-->(h:HOUSE))
WHERE id(n) IN nodes
RETURN h.Municipality As Municipi, h.Registry_Year AS `Any`, size(collect(n.Id)) AS `Nombre de Parelles`
ORDER BY `Any`, Municipi ASC;


- quantes components connexes no estan connectades a cap node de tipus ‘Habitatge’.
CALL gds.wcc.stream('Graph1')
YIELD componentId, nodeId
WITH componentId, collect(nodeId) as n1
WHERE size(n1) = 1
MATCH (n)
WHERE id(n) in n1
RETURN count(n) AS Nodes;

Una altra opció:
CALL gds.graph.project('Graph','PERSON','LIVES')

CALL gds.wcc.stream('prova')
YIELD componentId, nodeId
WITH componentId, collect(nodeId) AS nodes
MATCH (n)
WHERE (NOT (n)-->(:HOUSE)) AND (id(n) IN nodes)
RETURN count(DISTINCT componentId) AS NumComponents


Apartat b). Semblança entre els nodes. Ens interessa saber quins nodes són semblants com a pas
previ a identificar els individus que són el mateix (i unirem amb una aresta de tipus
SAME_AS). Abans de fer aquest anàlisi:

- Determineu els habitatges que són els mateixos al llarg dels anys. Afegiu una
aresta amb nom “MATEIX_HAB“ entre aquests habitatges. Per evitar arestes
duplicades feu que la aresta apunti al habitatge amb any de padró més petit.

MATCH (h1:HOUSE),(h2:HOUSE)
WHERE h1.Home_Id <> h2.Home_Id AND h1.Number=h2.Number AND h1.Municipality=h2.Municipality AND h1.Street=h2.Street AND h1.Registry_Year > h2.Registry_Year
MERGE (h2)-[:MATEIX_HAB]->(h1)
RETURN h1.Home_Id, h1.Number, h1.Municipality, h1.Street, h1.Registry_Year, h2.Home_Id, h2.Number, h2.Municipality, h2.Street, h2.Registry_Year


- Creeu un graf en memòria que inclogui els nodes Individu i Habitatge i les
relacions VIU, FAMILIA, MATEIX_HAB que acabeu de crear.

CALL gds.graph.project('Graph3',['PERSON', 'HOUSE'], ['LIVES', 'FAMILY', 'MATEIX_HAB'])


- Calculeu la similaritat entre els nodes del graf que acabeu de crear, escriviu el
resultat de nou a la base de dades i interpreteu els resultats obtinguts.

CALL gds.nodeSimilarity.write('Graph3',{
  writeRelationshipType:'SIMILAR',
  writeProperty:'score',
  similarityCutoff:0.30
  })
YIELD nodesCompared, relationshipsWritten
  
MATCH p=()-[r:SIMILAR]->(:HOUSE) RETURN p


