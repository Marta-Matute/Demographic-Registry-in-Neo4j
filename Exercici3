//a) Estudi de les components connexes (cc) i de l’estructura de les component en funció de la seva mida.

CALL gds.graph.project('Graph1', ['PERSON', 'HOUSE'], 'LIVES');
- Taula agrupant els resultats segons la mida de la cc.
CALL gds.graph.project('Graph2',['HOUSE','PERSON'],['FAMILY','SAME_AS','LIVES']);

CALL gds.wcc.stream('Graph2')
YIELD componentId, nodeId
RETURN componentId, size(collect(nodeId)) AS mida, collect(nodeId) AS nodes
ORDER BY mida DESC;

- Distribució de tipus de nodes (Individu o Habitatge) segons la mida de la cc.


- Per cada municipi i any el nombre de parelles del tipus: (Individu)—(Habitatge)
CALL gds.wcc.stream('Graph1')
YIELD componentId, nodeId 
WITH gds.util.asNode(nodeId) AS n1, componentId
WITH componentId, n1
WHERE n1.Municipality <> 'null'
RETURN DISTINCT n1.Year, n1.Municipality , max(componentId);

Una altra opció:
CALL gds.graph.project('Graph','PERSON','LIVES')

CALL gds.wcc.stream('Graph')
YIELD componentId, nodeId
WITH componentId, collect(nodeId) AS nodes, size(collect(nodeId)) AS mida
ORDER BY mida DESC
MATCH path=((n)-->(h:HOUSE))
WHERE id(n) IN nodes
RETURN h.Municipality As Municipi, h.Registry_Year AS `Any`, size(collect(n.Id)) AS `Nombre de Parelles`
ORDER BY Municipi,`Any` ASC


- quantes components connexes no estan connectades a cap node de tipus ‘Habitatge’.
CALL gds.wcc.stream('Graph1')
YIELD componentId, nodeId
WITH componentId, collect(nodeId) as n1
WHERE size(n1) = 1
MATCH (n)
WHERE id(n) in n1
RETURN count(n) AS Nodes;

Una altra opció:
CALL gds.graph.project('Graph','PERSON','LIVES')

CALL gds.wcc.stream('prova')
YIELD componentId, nodeId
WITH componentId, collect(nodeId) AS nodes
MATCH (n)
WHERE (NOT (n)-->(:HOUSE)) AND (id(n) IN nodes)
RETURN count(DISTINCT componentId) AS NumComponents


//(b)Semblança entre els nodes. Ens interessa saber quins nodes són semblants com a pas
previ a identificar els individus que són el mateix (i unirem amb una aresta de tipus
SAME_AS). Abans de fer aquest anàlisi:

- Determineu els habitatges que són els mateixos al llarg dels anys. Afegiu una
aresta amb nom “MATEIX_HAB“ entre aquests habitatges. Per evitar arestes
duplicades feu que la aresta apunti al habitatge amb any de padró més petit.

MATCH (h1:HOUSE),(h2:HOUSE)
WHERE h1.Home_Id <> h2.Home_Id AND h1.Number=h2.Number AND h1.Municipality=h2.Municipality AND h1.Street=h2.Street AND h1.Registry_Year > h2.Registry_Year
MERGE (h2)-[:MATEIX_HAB]->(h1)
RETURN h1.Home_Id, h1.Number, h1.Municipality, h1.Street, h1.Registry_Year, h2.Home_Id, h2.Number, h2.Municipality, h2.Street, h2.Registry_Year


- Creeu un graf en memòria que inclogui els nodes Individu i Habitatge i les
relacions VIU, FAMILIA, MATEIX_HAB que acabeu de crear.

CALL gds.graph.project('Graph3',['PERSON', 'HOUSE'], ['LIVES', 'FAMILY', 'MATEIX_HAB'])

- Calculeu la similaritat entre els nodes del graf que acabeu de crear, escriviu el
resultat de nou a la base de dades i interpreteu els resultats obtinguts.

CALL gds.nodeSimilarity.write('Graph3',{
  writeRelationshipType:'SIMILAR',
  writeProperty:'score',
  similarityCutoff:0.30
  })
  
MATCH (p1:PERSON)-[s:SIMILAR]->(p2:PERSON)
RETURN p1.Name, p2.Name, s.score
ORDER BY s.score ASC


YIELD nodesCompared, relationshipsWritten
